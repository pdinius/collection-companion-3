"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bgg = void 0;
const transformers_1 = require("./transformers");
const browser_xml_1 = require("browser-xml");
const utils_1 = require("./utils");
const baseUrl = "https://boardgamegeek.com/xmlapi2/";
const transformerDict = {
    collection: transformers_1.transformRawCollectionToCollection,
    thing: transformers_1.transformRawThingToThing,
};
const execute = async (url, attempts = 5) => {
    if (attempts === 0) {
        throw Error("Ran out of attempts.");
    }
    try {
        const response = await fetch(url);
        if (response.status === 202) {
            await (0, utils_1.timeout)(5, "seconds");
            return execute(url, --attempts);
        }
        if (response.status === 429) {
            const time = Number(response.headers.get('Retry-After'));
            if (time) {
                await (0, utils_1.timeout)(time);
            }
            else {
                await (0, utils_1.timeout)(15, "seconds");
            }
            return execute(url, --attempts);
        }
        else if (response.status >= 400) {
            throw Error(await response.text());
        }
        const data = await response.text();
        return (0, browser_xml_1.parse)(data);
    }
    catch (e) {
        if (e instanceof Error) {
            throw Error(e.message);
        }
        else {
            throw Error('Failed to fetch from bgg.');
        }
    }
};
const getWithTimeout = (command, params) => {
    // concatenate the url
    const paramsString = Object.entries(params)
        .map(([key, val]) => `${key}=${val}`)
        .join("&");
    let url = baseUrl + command;
    if (paramsString.length)
        url += `?${paramsString}`;
    return execute(url);
};
const bgg = async (c, params) => {
    const resParams = {};
    for (const p in params) {
        if (typeof params[p] === "boolean") {
            resParams[p] = params[p] ? "1" : "0";
        }
        else if (Object.prototype.toString.call(params[p]) === "[object Date]") {
            const d = params[p];
            resParams[p] =
                String(d.getFullYear()).slice(2) +
                    String(d.getMonth()).padStart(2, "0") +
                    String(d.getDate()).padStart(2, "0");
        }
        else {
            resParams[p] = params[p];
        }
    }
    const data = await getWithTimeout(c, resParams);
    return transformerDict[c](data);
};
exports.bgg = bgg;
