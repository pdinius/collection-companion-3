"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bgg = void 0;
const transformers_1 = require("./transformers");
const browser_xml_1 = require("browser-xml");
const utils_1 = require("./utils");
const moment_1 = __importDefault(require("moment"));
const MAX_ATTEMPTS = 10;
const baseUrl = "https://boardgamegeek.com/xmlapi2/";
const transformerDict = {
    collection: transformers_1.transformRawCollectionToCollection,
    thing: transformers_1.transformRawThingToThing,
    plays: transformers_1.transformRawPlaysToPlays,
    search: transformers_1.transformRawSearchToSearch,
};
const execute = async (url, attempts = MAX_ATTEMPTS, attempt = 1) => {
    if (attempts === 0) {
        throw Error("Ran out of attempts.");
    }
    try {
        console.log(`Attempt #${attempt}. ${attempts} attempts remaining.`);
        const response = await fetch(url);
        if (response.status === 202) {
            await (0, utils_1.timeout)(3, "seconds");
            return execute(url, --attempts, ++attempt);
        }
        if (response.status >= 400) {
            throw Error(await response.text());
        }
        const data = await response.text();
        return (0, browser_xml_1.parse)(data);
    }
    catch (e) {
        if (e instanceof Error) {
            console.error(e.message);
            console.log("Backing off for 15 seconds.");
            await (0, utils_1.timeout)(15, "seconds");
            return execute(url, --attempts, ++attempt);
        }
        else {
            // should never get here
            throw Error("Failed to fetch from bgg.");
        }
    }
};
const getWithTimeout = async (command, params, transformer, useCache) => {
    // concatenate the url
    const paramsString = Object.entries(params)
        .map(([key, val]) => `${key}=${val}`)
        .join("&");
    let url = baseUrl + command;
    if (paramsString.length)
        url += `?${paramsString}`;
    let cacheItem = "";
    if (useCache && typeof window !== "undefined") {
        cacheItem = localStorage.getItem(url);
    }
    if (cacheItem) {
        return JSON.parse(cacheItem);
    }
    else {
        const res = transformer(await execute(url));
        if (typeof window !== "undefined")
            localStorage.setItem(url, JSON.stringify(res));
        return res;
    }
};
const bgg = (c, params, useCache = true) => {
    const resParams = {};
    for (const p in params) {
        const el = params[p];
        if (typeof el === "boolean") {
            resParams[p] = el ? "1" : "0";
        }
        else if (el instanceof Date) {
            resParams[p] = (0, moment_1.default)(el).format("YY-MM-DD%20HH:mm:ss");
        }
        else {
            resParams[p] = el;
        }
    }
    return getWithTimeout(c, resParams, transformerDict[c], useCache);
};
exports.bgg = bgg;
